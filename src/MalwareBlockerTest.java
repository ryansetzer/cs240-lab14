import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;

/**
 * Correctness and performance tests for MalwareBlocker.
 * 
 * @author Nathan Sprague
 *
 */
@TestMethodOrder(OrderAnnotation.class)
class MalwareBlockerTest {

  /**
   * Generate a random list of doubles guaranteeing no repeats.
   * 
   * @param howMany how many to create
   * @param avoid don't include any from this list
   * @return howMany doubles
   */
  public List<String> randomStrings(int howMany, List<String> avoid) {
    List<String> result = new ArrayList<>();
    Random gen = new Random(100101);
    HashSet<String> seen = new HashSet<>();
    HashSet<String> avoidSet = new HashSet<>(avoid);

    while (result.size() < howMany) {
      double price = gen.nextDouble();
      String url = "url" + price;

      if (!seen.contains(url) && !avoidSet.contains(url)) {
        seen.add(url);
        result.add(url);
      }
    }
    return result;
  }



  @Test
  @Order(1)
  void testFunctionality() {
    MalwareBlocker blocker = new MalwareBlocker();

    assertEquals(false, blocker.isBlocked("a"));

    String[] blocked = { "a", "b", "c" };

    for (String s : blocked) {
      blocker.blockSite(s);
      assertTrue(blocker.isBlocked(s));
    }
    assertEquals(3, blocker.size());

    for (String s : blocked) {
      blocker.blockSite(s);
      assertTrue(blocker.isBlocked(s));
    }
    assertEquals(3, blocker.size());

    assertTrue(!blocker.isBlocked("d"));

  }

  private void timePerformance(int fillAmount, int lookupAmount) {
    long addTime;
    long buyTime;

    MalwareBlocker blocker = new MalwareBlocker();

    System.out.println("GENERATING RANDOM DATA...");

    // A bunch of random doubles, not including ("")
    List<String> empty = new ArrayList<>();
    List<String> initialSites = randomStrings(fillAmount, empty);
    List<String> dynamicSites = randomStrings(lookupAmount, initialSites);
    List<String> searchSites = randomStrings(lookupAmount, empty);

    System.out.println("TIMING LONG SEQUENCE OF ADDS...");
    long start = System.nanoTime();
    for (int i = 0; i < initialSites.size(); i++) {
      blocker.blockSite(initialSites.get(i));
    }
    addTime = System.nanoTime() - start;

    System.out.println("TIMING ALTERNATING ADDS AND LOOKUPS...");
    start = System.nanoTime();
    for (int i = 0; i < lookupAmount; i++) {
      blocker.blockSite(dynamicSites.get(i));
      blocker.isBlocked(searchSites.get(i));
    }
    buyTime = System.nanoTime() - start;

    System.out.printf("\nTOTAL TIME: %.2f seconds.\n", (addTime + buyTime) / 1000000000.0);

  }

  @Test
  @Order(2)
  void testPerformance() {

    timePerformance(400000, 400000);

    System.out.println("\nDOUBLING THE NUMBER OF OPERATIONS...\n");

    timePerformance(800000, 800000);

  }

}

